
# Construction d'un graphe LangGraph : Documentation complète

## Introduction aux graphes LangGraph

Cette documentation explique comment construire un graphe d'agents (LangGraph) pour générer des réponses avancées intégrant des recherches en temps réel. Le système suit une architecture en trois phases principales : génération d'une première ébauche, exécution d'outils de recherche, et révision du contenu.

## Importations nécessaires

Pour commencer, nous devons importer les composants essentiels :

```python
from typing import List
from langchain_core.messages import BaseMessage, ToolMessage
from langgraph.graph import END, MessageGraph

from chains import revisor, first_responder
from tool_executor import execute_tools
```

Ces importations incluent :
- Les types `List` pour le typage
- Les classes `BaseMessage` et `ToolMessage` qui représenteront les états de notre graphe
- Le mot-clé `END` qui référence le nœud final qui terminera l'exécution du graphe
- `MessageGraph` : un graphe intégré dont l'état est une liste de messages
- Les chaînes `revisor` et `first_responder` pour traiter les étapes de notre flux
- La fonction `execute_tools` qui exécutera les recherches de données en temps réel

## Construction du graphe

Nous commençons par définir une constante `MAX_ITERATIONS` qui limite le nombre de cycles entre critique et révision :

```python
MAX_ITERATIONS = 2
```

Cette valeur (2) est simplement une heuristique qui nous permet de limiter les itérations dans le nœud de critique et révision.

### Création des nœuds

Nous initialisons d'abord notre graphe de messages :

```python
builder = MessageGraph()
```

Puis nous ajoutons les trois nœuds principaux :

```python
builder.add_node("draft", first_responder)
builder.add_node("execute_tools", execute_tools)
builder.add_node("revise", revisor)
```

- Le nœud `draft` exécute la chaîne `first_responder` qui génère la première ébauche, intègre une critique et identifie les requêtes de recherche à exécuter
- Le nœud `execute_tools` exécute la fonction `execute_tools` qui traite l'état actuel et effectue des recherches de données en temps réel
- Le nœud `revise` exécute la chaîne `revisor` qui améliore la réponse en fonction des données récupérées

### Création des arêtes

Nous connectons ensuite nos nœuds pour créer le flux de travail :

```python
builder.add_edge("draft", "execute_tools")
builder.add_edge("execute_tools", "revise")
```

Ces arêtes définissent le flux de base de notre graphe : de l'ébauche vers l'exécution des outils, puis vers la révision.

### Logique conditionnelle pour les itérations

Pour contrôler le nombre d'itérations, nous créons une fonction `event_loop` qui décide du prochain nœud à exécuter après la révision :

```python
def event_loop(state: List[BaseMessage]) -> str:
    count_tool_visits = sum(isinstance(item, ToolMessage) for item in state)
    num_iterations = count_tool_visits
    if num_iterations > MAX_ITERATIONS:
        return END
    return "execute_tools"
```

Cette fonction :
1. Compte le nombre de messages de type `ToolMessage` dans l'état actuel (chaque message de ce type représente une exécution d'outil précédente)
2. Si ce nombre dépasse `MAX_ITERATIONS`, retourne `END` pour terminer l'exécution
3. Sinon, retourne `"execute_tools"` pour effectuer une nouvelle itération de recherche

Nous l'ajoutons au graphe comme arête conditionnelle partant du nœud de révision :

```python
builder.add_conditional_edges("revise", event_loop)
```

### Configuration et compilation

Finalement, nous définissons le point d'entrée et compilons le graphe :

```python
builder.set_entry_point("draft")
graph = builder.compile()
```

## Visualisation du graphe

Pour visualiser notre graphe, nous pouvons utiliser la syntaxe Mermaid :

```python
print(graph.get_graph().draw_mermaid())
```

Cette commande génère une représentation visuelle du graphe qui peut être affichée sous forme d'image.

## Exécution du graphe

Pour exécuter notre graphe avec une requête spécifique :

```python
res = graph.invoke(
    "Write about AI-Powered SOC / autonomous soc problem domain, list startups that do that and raised capital."
)
```

La réponse finale peut être extraite de l'objet de résultat :

```python
print(res[-1].tool_calls[0]["args"]["answer"])
```

Pour des besoins de débogage ou d'analyse, nous pouvons également afficher l'ensemble des traces :

```python
print(res)
```

## Analyse des traces

Les traces d'exécution permettent d'inspecter chaque étape du processus :
- Le premier prompt envoyé au LLM pour générer l'ébauche
- Les exécutions d'outils de recherche avec leurs résultats
- Les itérations successives de révision
- La réponse finale générée

Cette inspection est particulièrement utile pour le débogage et l'optimisation du graphe.

## Conclusion

Ce système LangGraph nous permet de créer un agent capable de :
1. Générer une première réponse (ébauche)
2. Identifier les données manquantes et exécuter des recherches
3. Réviser la réponse en fonction des nouvelles informations
4. Itérer ce processus jusqu'à obtenir un résultat optimal

La flexibilité de cette architecture permet de l'adapter à diverses applications nécessitant des réponses informées par des données en temps réel.