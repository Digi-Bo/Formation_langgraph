
# Implémentation d'un exécuteur d'outils dans un agent de réflexion
Ce document explique comment implémenter un exécuteur d'outils (tool executor) dans le cadre d'un agent de réflexion utilisant LangChain et LangGraph. L'objectif est de créer un système capable d'effectuer des recherches, de répondre à des questions, puis d'améliorer ses réponses grâce à une phase de réflexion et de révision.

# *Implementation of a tool executor in a reflection agent*
*This document explains how to implement a tool executor in the context of a reflection agent using LangChain and LangGraph. The goal is to create a system capable of performing research, answering questions, and then improving its answers through a reflection and revision phase.*

---

# Configuration du projet
Avant de commencer, assurez-vous d'avoir installé les dépendances nécessaires. Le projet utilise Poetry comme gestionnaire de paquets, avec les dépendances suivantes :

```
langchain
langgraph
langchain-openai
python-dotenv
langchain-tavily
```

Pour installer la bibliothèque langchain-tavily spécifiquement, utilisez la commande :

```bash
poetry add langchain-tavily
```

# *Project setup*
*Before starting, make sure you have installed the necessary dependencies. The project uses Poetry as a package manager, with the following dependencies:*

```
langchain
langgraph
langchain-openai
python-dotenv
langchain-tavily
```

*To install the langchain-tavily library specifically, use the command:*

```bash
poetry add langchain-tavily
```

---

# Création de l'exécuteur d'outils

## Structure des fichiers
Notre projet comporte plusieurs fichiers :
- `chains.py` : contient la définition des chaînes de traitement
- `schemas.py` : définit les schémas de données (classes AnswerQuestion et ReviseAnswer)
- `tool_executor.py` : implémente l'exécuteur d'outils que nous allons créer

# *Creating the tool executor*

## *File structure*
*Our project consists of several files:*
- *`chains.py`: contains the definition of processing chains*
- *`schemas.py`: defines data schemas (AnswerQuestion and ReviseAnswer classes)*
- *`tool_executor.py`: implements the tool executor we are going to create*

---

## Implémentation de l'exécuteur d'outils
Commençons par créer le fichier `tool_executor.py`. Cette classe sera responsable de l'exécution des requêtes de recherche.

```python
from dotenv import load_dotenv

load_dotenv()

from langchain_core.tools import StructuredTool
from langchain_tavily import TavilySearch
from langgraph.prebuilt import ToolNode

from schemas import AnswerQuestion, ReviseAnswer

tavily_tool = TavilySearch(max_results=5)


def run_queries(search_queries: list[str], **kwargs):
    """Run the generated queries."""
    return tavily_tool.batch([{"query": query} for query in search_queries])


execute_tools = ToolNode(
    [
        StructuredTool.from_function(run_queries, name=AnswerQuestion.__name__),
        StructuredTool.from_function(run_queries, name=ReviseAnswer.__name__),
    ]
)
```

## *Tool executor implementation*
*Let's start by creating the `tool_executor.py` file. This class will be responsible for executing search queries.*

```python
from dotenv import load_dotenv

load_dotenv()

from langchain_core.tools import StructuredTool
from langchain_tavily import TavilySearch
from langgraph.prebuilt import ToolNode

from schemas import AnswerQuestion, ReviseAnswer

tavily_tool = TavilySearch(max_results=5)


def run_queries(search_queries: list[str], **kwargs):
    """Run the generated queries."""
    return tavily_tool.batch([{"query": query} for query in search_queries])


execute_tools = ToolNode(
    [
        StructuredTool.from_function(run_queries, name=AnswerQuestion.__name__),
        StructuredTool.from_function(run_queries, name=ReviseAnswer.__name__),
    ]
)
```

---

# Composants clés

## Importation et configuration
Commençons par charger les variables d'environnement :

```python
from dotenv import load_dotenv
load_dotenv()
```

Assurez-vous d'avoir configuré votre fichier `.env` avec la clé API Tavily :

```
TAVILY_API_KEY=votre_clé_api
```

# *Key components*

## *Import and configuration*
*Let's start by loading the environment variables:*

```python
from dotenv import load_dotenv
load_dotenv()
```

*Make sure you have configured your `.env` file with the Tavily API key:*

```
TAVILY_API_KEY=your_api_key
```

---

## Tavily Search
Nous utilisons l'outil de recherche Tavily, qui est intégré à LangChain :

```python
from langchain_tavily import TavilySearch
tavily_tool = TavilySearch(max_results=5)
```

Cet outil nous permettra d'effectuer des recherches en ligne avec un maximum de 5 résultats par requête.

## *Tavily Search*
*We use the Tavily search tool, which is integrated with LangChain:*

```python
from langchain_tavily import TavilySearch
tavily_tool = TavilySearch(max_results=5)
```

*This tool will allow us to perform online searches with a maximum of 5 results per query.*

---

## Structured Tool
La classe `StructuredTool` de LangChain est utilisée pour convertir une fonction Python en un outil structuré :

```python
from langchain_core.tools import StructuredTool
```

Cette classe permet de créer un schéma structuré pour notre fonction, ce qui aide le modèle de langage à comprendre comment l'utiliser.

## *Structured Tool*
*The `StructuredTool` class from LangChain is used to convert a Python function into a structured tool:*

```python
from langchain_core.tools import StructuredTool
```

*This class allows us to create a structured schema for our function, which helps the language model understand how to use it.*

---

## Tool Node
La classe `ToolNode` de LangGraph est un composant qui simplifie considérablement l'intégration des outils :

```python
from langgraph.prebuilt import ToolNode
```

Cette classe joue un rôle essentiel car elle :
- Examine l'état du graphe pour trouver la clé "messages"
- Vérifie le dernier message pour identifier les appels d'outils
- Exécute automatiquement les outils appropriés, même en parallèle

Avant l'introduction de cette classe, il fallait implémenter manuellement toute cette logique, ce qui représentait un travail considérable.

## *Tool Node*
*The `ToolNode` class from LangGraph is a component that greatly simplifies tool integration:*

```python
from langgraph.prebuilt import ToolNode
```

*This class plays an essential role because it:*
- *Examines the graph state to find the "messages" key*
- *Checks the last message to identify tool calls*
- *Automatically executes the appropriate tools, even in parallel*

*Before the introduction of this class, all this logic had to be manually implemented, which represented considerable work.*

---

# Stratégie d'implémentation

## Fonction d'exécution des requêtes
Nous définissons une fonction `run_queries` qui exécute une liste de requêtes de recherche :

```python
def run_queries(search_queries: list[str], **kwargs):
    """Run the generated queries."""
    return tavily_tool.batch([{"query": query} for query in search_queries])
```

Cette fonction utilise la méthode `batch` de l'outil Tavily pour exécuter plusieurs requêtes en parallèle.

# *Implementation strategy*

## *Query execution function*
*We define a `run_queries` function that executes a list of search queries:*

```python
def run_queries(search_queries: list[str], **kwargs):
    """Run the generated queries."""
    return tavily_tool.batch([{"query": query} for query in search_queries])
```

*This function uses the `batch` method of the Tavily tool to execute multiple queries in parallel.*

---

## Création de deux outils distincts
La particularité de notre approche est de créer deux outils différents à partir de la même fonction de recherche :

```python
execute_tools = ToolNode(
    [
        StructuredTool.from_function(run_queries, name=AnswerQuestion.__name__),
        StructuredTool.from_function(run_queries, name=ReviseAnswer.__name__),
    ]
)
```

Ces deux outils ont exactement la même fonctionnalité (exécuter des recherches via Tavily) mais possèdent des noms différents :
- `AnswerQuestion` : utilisé pendant la phase initiale de recherche
- `ReviseAnswer` : utilisé pendant la phase de révision

Cette distinction permet de suivre clairement quelle étape du processus a déclenché la recherche, ce qui facilite le débogage et l'évaluation du système.

## *Creating two distinct tools*
*The particularity of our approach is to create two different tools from the same search function:*

```python
execute_tools = ToolNode(
    [
        StructuredTool.from_function(run_queries, name=AnswerQuestion.__name__),
        StructuredTool.from_function(run_queries, name=ReviseAnswer.__name__),
    ]
)
```

*These two tools have exactly the same functionality (executing searches via Tavily) but have different names:*
- *`AnswerQuestion`: used during the initial research phase*
- *`ReviseAnswer`: used during the revision phase*

*This distinction allows for clearly tracking which step of the process triggered the search, which facilitates debugging and system evaluation.*

---

# Intégration avec le reste du système
Le fichier `chains.py` définit deux chaînes principales :
1. `first_responder` : génère une réponse initiale à la question de l'utilisateur
2. `revisor` : améliore la réponse en fonction des critiques et des nouvelles informations

L'exécuteur d'outils que nous avons créé (`execute_tools`) sera intégré dans un graphe LangGraph qui orchestrera le flux entre ces différentes étapes.

# *Integration with the rest of the system*
*The `chains.py` file defines two main chains:*
1. *`first_responder`: generates an initial response to the user's question*
2. *`revisor`: improves the response based on critiques and new information*

*The tool executor we created (`execute_tools`) will be integrated into a LangGraph graph that will orchestrate the flow between these different stages.*

---

# Conclusion
L'exécuteur d'outils que nous avons implémenté constitue une partie essentielle de notre agent de réflexion. En utilisant les classes `StructuredTool` et `ToolNode`, nous avons pu simplifier considérablement le processus d'intégration des outils de recherche dans notre système.

La distinction entre les phases de recherche initiale et de révision, bien qu'utilisant la même fonctionnalité sous-jacente, permet d'améliorer la traçabilité et l'analyse du comportement de l'agent.

# *Conclusion*
*The tool executor we have implemented is an essential part of our reflection agent. By using the `StructuredTool` and `ToolNode` classes, we have been able to greatly simplify the process of integrating search tools into our system.*

*The distinction between the initial research and revision phases, although using the same underlying functionality, improves the traceability and analysis of agent behavior.*

---

## Lexique technique / Technical Vocabulary

| Français | English |
|----------|---------|
| exécuteur d'outils | tool executor |
| agent de réflexion | reflection agent |
| chaînes de traitement | processing chains |
| schémas de données | data schemas |
| gestionnaire de paquets | package manager |
| variables d'environnement | environment variables |
| outil de recherche | search tool |
| fonction d'exécution des requêtes | query execution function |
| phase initiale de recherche | initial research phase |
| phase de révision | revision phase |
| débogage | debugging |
| traçabilité | traceability |
| fonctionnalité sous-jacente | underlying functionality |