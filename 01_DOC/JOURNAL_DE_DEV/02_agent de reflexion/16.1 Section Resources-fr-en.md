# Document d'apprentissage Français-Anglais : Agent de Réflexion avec LangGraph

## Dépôt GitHub pour l'Agent de Réflexion
Ce projet implémente un Agent de Réflexion utilisant LangChain et LangGraph. L'agent est conçu pour générer et affiner des tweets en utilisant un processus itératif d'auto-évaluation et d'amélioration.

## GitHub Repository for Reflexion Agent
*This project implements a Reflexion Agent using LangChain and LangGraph. The agent is designed to generate and refine tweets using an iterative process of self-evaluation and improvement.*

---

## Chronologie de développement
La structure de ce dépôt GitHub suit l'organisation des cours sur les agents de réflexion, démontrant les concepts clés dans la construction d'un Agent de Réflexion.

## Development Timeline
*The structure of this GitHub repository follows the organization of the courses on reflection agents, demonstrating the key concepts in building a Reflexion Agent.*

---

### 1. Mise en place de la structure initiale du projet
*Correspond au cours 16 : Configuration du projet*

Cette étape établit les fondations avec les fichiers de configuration essentiels :
- `.gitignore` pour exclure certains fichiers du suivi Git
- `main.py` comme point d'entrée de l'application
- `pyproject.toml` pour la gestion des dépendances et la configuration du projet
- `poetry.lock` pour verrouiller les versions des dépendances

### 1. Add initial project structure
*Corresponds to Lecture 16: Project Setup*

*This step establishes the foundation with essential configuration files:*
- `.gitignore` *to exclude certain files from Git tracking*
- `main.py` *as the application entry point*
- `pyproject.toml` *for dependency management and project configuration*
- `poetry.lock` *to lock dependency versions*

---

### 2. Création des chaînes pour la fonctionnalité de génération
*Correspond au cours 17 : Agent Acteur (Actor Agent)*

À cette étape, nous implémentons le premier composant de notre architecture d'agent - l'Acteur :
- Ajout de `chains.py` avec des modèles de prompts (templates) pour générer des tweets
- Configuration des schémas avec des modèles Pydantic pour la gestion structurée des données

### 2. Create chains for AI-powered research functionality
*Corresponds to Lecture 17: Actor Agent*

*At this stage, we implement the first component of our agent architecture - the Actor:*
- *Addition of `chains.py` with prompt templates for generating tweets*
- *Configuration of schemas with Pydantic models for structured data handling*

---

### 3. Amélioration des chaînes pour les capacités de révision
*Correspond au cours 18 : Agent Réviseur (Revisor Agent)*

Nous implémentons ici le deuxième composant - le Réviseur pour l'auto-réflexion :
- Ajout de la classe `ReviseAnswer` dans `schemas.py` pour une structure de réponse améliorée
- Mise à jour des prompts de chaîne pour intégrer des critiques et des exigences d'amélioration

### 3. Enhance chains for answer revision capabilities
*Corresponds to Lecture 18: Revisor Agent*

*Here we implement the second component - the Revisor for self-reflection:*
- *Addition of the `ReviseAnswer` class in `schemas.py` for an improved response structure*
- *Update of chain prompts to incorporate critique and improvement requirements*

---

### 4. Ajout de dépendances et d'outils pour les nœuds du graphe
*Correspond au cours 19 : Nœud d'Outil (ToolNode) - Exécution d'outils*

Cette phase intègre des fonctionnalités supplémentaires pour améliorer la précision des réponses :
- Intégration de fonctionnalités de recherche pour enrichir la génération de contenu
- Ajout des dépendances requises pour le flux de travail complet du graphe

### 4. Add dependencies and tools for graph nodes
*Corresponds to Lecture 19: ToolNode - Executing Tools*

*This phase integrates additional functionalities to improve response accuracy:*
- *Integration of search functionality to enrich content generation*
- *Addition of required dependencies for the complete graph workflow*

---

### 5. Implémentation du graphe de messages complet
*Correspond au cours 20 : Construction de notre Graphe LangGraph*

Nous connectons ici les agents Acteur et Réviseur dans un flux de travail LangGraph complet :
- Définition des nœuds de graphe pour la rédaction, l'exécution d'outils et la révision
- Établissement de la gestion d'état et du routage conditionnel pour la réflexion
- Configuration du flux de traitement itératif pour l'amélioration continue des tweets

### 5. Implement the complete message graph
*Corresponds to Lecture 20: Building our LangGraph Graph*

*Here we connect the Actor and Revisor agents in a complete LangGraph workflow:*
- *Definition of graph nodes for drafting, tool execution, and revision*
- *Establishment of state management and conditional edge routing for reflection*
- *Configuration of the iterative processing flow for continuous tweet improvement*

---

## Architecture technique
L'agent est construit autour de deux chaînes LangChain principales :
1. **Chaîne de génération** : crée des tweets basés sur les demandes de l'utilisateur
2. **Chaîne de réflexion** : évalue les tweets générés et fournit des critiques constructives

Ces chaînes sont ensuite orchestrées dans un graphe LangGraph qui permet un processus itératif d'amélioration du contenu.

## Technical Architecture
*The agent is built around two main LangChain chains:*
1. **Generation chain**: *creates tweets based on user requests*
2. **Reflection chain**: *evaluates generated tweets and provides constructive criticism*

*These chains are then orchestrated in a LangGraph graph that enables an iterative process of content improvement.*

---

## Flux de travail
1. L'utilisateur fournit une demande initiale de génération ou d'amélioration de tweet
2. Le nœud de génération crée un tweet initial
3. Le nœud de réflexion évalue ce tweet et formule des recommandations d'amélioration
4. Le nœud de génération utilise ces recommandations pour améliorer le tweet
5. Ce cycle se répète jusqu'à ce qu'une condition d'arrêt soit atteinte (dans l'exemple, après un certain nombre d'itérations)

## Workflow
*1. The user provides an initial request for tweet generation or improvement*
*2. The generation node creates an initial tweet*
*3. The reflection node evaluates this tweet and formulates improvement recommendations*
*4. The generation node uses these recommendations to improve the tweet*
*5. This cycle repeats until a stop condition is reached (in the example, after a certain number of iterations)*

---

## Composants clés
- **MessageGraph** (Graphe de messages) : structure qui organise le flux de traitement
- **Nœuds** : fonctions qui exécutent des tâches spécifiques (génération, réflexion)
- **Arêtes conditionnelles** : logique qui détermine le chemin à suivre dans le graphe
- **Chaînes LangChain** : séquences d'opérations avec des modèles de langage

## Key Components
- **MessageGraph**: *structure that organizes the processing flow*
- **Nodes**: *functions that execute specific tasks (generation, reflection)*
- **Conditional Edges**: *logic that determines the path to follow in the graph*
- **LangChain Chains**: *sequences of operations with language models*

---

## Guide du code

### Module chains.py
Ce module définit deux chaînes LangChain distinctes qui travaillent ensemble pour générer et améliorer des tweets:
1. Une chaîne de génération qui crée des tweets basés sur les demandes de l'utilisateur
2. Une chaîne de réflexion qui évalue les tweets générés et fournit des critiques

### chains.py Module
*This module defines two distinct LangChain chains that work together to generate and improve tweets:*
*1. A generation chain that creates tweets based on user requests*
*2. A reflection chain that evaluates generated tweets and provides criticism*

---

### Importations dans chains.py
Nous importons :
- `ChatPromptTemplate` : permet de structurer le contenu envoyé au modèle de langage (LM)
- `MessagesPlaceholder` : permet de créer un emplacement pour les messages futurs
- `ChatOpenAI` : interface pour interagir avec les modèles OpenAI

### Imports in chains.py
*We import:*
- `ChatPromptTemplate`: *allows structuring content sent to the language model (LM)*
- `MessagesPlaceholder`: *allows creating a placeholder for future messages*
- `ChatOpenAI`: *interface for interacting with OpenAI models*

```python
from langchain_core.prompts import ChatPromptTemplate, MessagesPlaceholder
from langchain_openai import ChatOpenAI
```

---

### Configuration des prompts
Deux templates de prompts sont définis :
1. `reflection_prompt` : instruit le LLM d'agir comme un influenceur Twitter évaluant un tweet
2. `generation_prompt` : instruit le LLM d'agir comme un assistant influenceur technique rédigeant des tweets

### Prompt Configuration
*Two prompt templates are defined:*
*1. `reflection_prompt`: instructs the LLM to act as a Twitter influencer evaluating a tweet*
*2. `generation_prompt`: instructs the LLM to act as a technical influencer assistant writing tweets*

```python
reflection_prompt = ChatPromptTemplate.from_messages(
    [
        (
            "system",
            "Vous êtes un influenceur viral sur Twitter évaluant un tweet. Générez une critique et des recommandations pour le tweet de l'utilisateur."
            "Fournissez toujours des recommandations détaillées, y compris des demandes concernant la longueur, la viralité, le style, etc.",
        ),
        MessagesPlaceholder(variable_name="messages"),
    ]
)

generation_prompt = ChatPromptTemplate.from_messages(
    [
        (
            "system",
            "Vous êtes un assistant influenceur technique sur Twitter chargé de rédiger d'excellents posts Twitter."
            " Générez le meilleur post Twitter possible pour la demande de l'utilisateur."
            " Si l'utilisateur fournit une critique, répondez avec une version révisée de vos tentatives précédentes.",
        ),
        MessagesPlaceholder(variable_name="messages"),
    ]
)
```

---

### Initialisation du modèle et des chaînes
1. Initialisation du modèle OpenAI (o4-mini)
2. Création des chaînes :
   - `generate_chain` : connecte le prompt de génération au modèle de langage
   - `reflect_chain` : connecte le prompt de réflexion au modèle de langage

### Model and Chain Initialization
*1. Initialization of the OpenAI model (o4-mini)*
*2. Creation of chains:*
   - `generate_chain`: *connects the generation prompt to the language model*
   - `reflect_chain`: *connects the reflection prompt to the language model*

```python
llm = ChatOpenAI(model="o4-mini")

generate_chain = generation_prompt | llm
reflect_chain = reflection_prompt | llm
```

---

### Fichier main.py
Le fichier principal implémente le graphe de traitement LangGraph qui utilise les chaînes définies dans chains.py. Il définit la structure du flux de travail, les nœuds et leurs connexions.

### main.py File
*The main file implements the LangGraph processing graph that uses the chains defined in chains.py. It defines the workflow structure, nodes, and their connections.*

---

### Importations dans main.py
Nous importons :
- Types Python pour les annotations
- Chargement des variables d'environnement
- Classes et fonctions LangChain pour la gestion des messages
- Fonctionnalités LangGraph pour la construction de graphes
- Nos chaînes personnalisées (`generate_chain` et `reflect_chain`)

### Imports in main.py
*We import:*
- *Python types for annotations*
- *Environment variable loading*
- *LangChain classes and functions for message handling*
- *LangGraph functionalities for graph building*
- *Our custom chains (`generate_chain` and `reflect_chain`)*

```python
from typing import List, Sequence

from dotenv import load_dotenv
load_dotenv()

from langchain_core.messages import BaseMessage, HumanMessage
from langgraph.graph import END, MessageGraph

from chains import generate_chain, reflect_chain
```

---

### Définition des nœuds
Deux nœuds principaux sont définis :
1. `generation_node` : utilise la chaîne de génération pour créer des tweets
2. `reflection_node` : utilise la chaîne de réflexion pour évaluer les tweets

### Node Definition
*Two main nodes are defined:*
*1. `generation_node`: uses the generation chain to create tweets*
*2. `reflection_node`: uses the reflection chain to evaluate tweets*

```python
def generation_node(state: Sequence[BaseMessage]):
    return generate_chain.invoke({"messages": state})

def reflection_node(messages: Sequence[BaseMessage]) -> List[BaseMessage]:
    res = reflect_chain.invoke({"messages": messages})
    return [HumanMessage(content=res.content)]
```

---

### Construction du graphe
Le graphe est construit en utilisant le pattern Builder :
1. Initialisation du constructeur `MessageGraph`
2. Ajout des nœuds et définition du point d'entrée
3. Configuration des conditions de transition entre les nœuds
4. Compilation du graphe final

### Graph Construction
*The graph is built using the Builder pattern:*
*1. Initialization of the `MessageGraph` builder*
*2. Addition of nodes and definition of the entry point*
*3. Configuration of transition conditions between nodes*
*4. Compilation of the final graph*

```python
builder = MessageGraph()
builder.add_node(GENERATE, generation_node)
builder.add_node(REFLECT, reflection_node)
builder.set_entry_point(GENERATE)

def should_continue(state: List[BaseMessage]):
    if len(state) > 6:
        return END
    return REFLECT

builder.add_conditional_edges(GENERATE, should_continue)
builder.add_edge(REFLECT, GENERATE)

graph = builder.compile()
```

---

### Exécution du graphe
Le graphe est exécuté avec un tweet initial qui sera amélioré par le processus itératif de génération et réflexion.

### Graph Execution
*The graph is executed with an initial tweet that will be improved by the iterative process of generation and reflection.*

```python
if __name__ == "__main__":
    print("Hello LangGraph") 
    inputs = HumanMessage(content="""Améliore ce tweet : :"
                                    @LangChainAI
La nouvelle fonctionnalité "Tool Calling" est vraiment super !

Après une longue attente, elle est enfin là, rendant l'implémentation d'agents à travers différents modèles avec appel de fonctions incroyablement facile. 

J'ai réalisé une vidéo à propos de votre dernier article de blog. 

                                  """)
    response = graph.invoke(inputs)
    print(response)
```

---

## Lexique technique

| Français | Anglais |
|----------|---------|
| Agent de Réflexion | Reflexion Agent |
| Chaîne de génération | Generation chain |
| Chaîne de réflexion | Reflection chain |
| Graphe de messages | Message graph |
| Nœud de génération | Generation node |
| Nœud de réflexion | Reflection node |
| Arête conditionnelle | Conditional edge |
| Point d'entrée | Entry point |
| Modèle de langage | Language model (LM) |
| Modèles de prompts | Prompt templates |
| Agent Acteur | Actor Agent |
| Agent Réviseur | Revisor Agent |
| Nœud d'Outil | Tool Node |
| Flux de travail | Workflow |
| Gestion d'état | State management |
| Routage conditionnel | Conditional routing |