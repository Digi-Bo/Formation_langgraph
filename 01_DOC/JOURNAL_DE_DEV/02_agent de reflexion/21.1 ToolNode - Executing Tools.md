# Implémentation d'un exécuteur d'outils dans un agent de réflexion

## Introduction

Ce document explique comment implémenter un exécuteur d'outils (tool executor) dans le cadre d'un agent de réflexion utilisant LangChain et LangGraph. L'objectif est de créer un système capable d'effectuer des recherches, de répondre à des questions, puis d'améliorer ses réponses grâce à une phase de réflexion et de révision.

## Configuration du projet

Avant de commencer, assurez-vous d'avoir installé les dépendances nécessaires. Le projet utilise Poetry comme gestionnaire de paquets, avec les dépendances suivantes :

```
langchain
langgraph
langchain-openai
python-dotenv
langchain-tavily
```

Pour installer la bibliothèque langchain-tavily spécifiquement, utilisez la commande :

```bash
poetry add langchain-tavily
```

## Création de l'exécuteur d'outils

### Structure des fichiers

Notre projet comporte plusieurs fichiers :
- `chains.py` : contient la définition des chaînes de traitement
- `schemas.py` : définit les schémas de données (classes AnswerQuestion et ReviseAnswer)
- `tool_executor.py` : implémente l'exécuteur d'outils que nous allons créer

### Implémentation de l'exécuteur d'outils

Commençons par créer le fichier `tool_executor.py`. Cette classe sera responsable de l'exécution des requêtes de recherche.

```python
from dotenv import load_dotenv

load_dotenv()

from langchain_core.tools import StructuredTool
from langchain_tavily import TavilySearch
from langgraph.prebuilt import ToolNode

from schemas import AnswerQuestion, ReviseAnswer

tavily_tool = TavilySearch(max_results=5)


def run_queries(search_queries: list[str], **kwargs):
    """Run the generated queries."""
    return tavily_tool.batch([{"query": query} for query in search_queries])


execute_tools = ToolNode(
    [
        StructuredTool.from_function(run_queries, name=AnswerQuestion.__name__),
        StructuredTool.from_function(run_queries, name=ReviseAnswer.__name__),
    ]
)
```

## Composants clés

### Importation et configuration

Commençons par charger les variables d'environnement :

```python
from dotenv import load_dotenv
load_dotenv()
```

Assurez-vous d'avoir configuré votre fichier `.env` avec la clé API Tavily :

```
TAVILY_API_KEY=votre_clé_api
```

### Tavily Search

Nous utilisons l'outil de recherche Tavily, qui est intégré à LangChain :

```python
from langchain_tavily import TavilySearch
tavily_tool = TavilySearch(max_results=5)
```

Cet outil nous permettra d'effectuer des recherches en ligne avec un maximum de 5 résultats par requête.

### Structured Tool

La classe `StructuredTool` de LangChain est utilisée pour convertir une fonction Python en un outil structuré :

```python
from langchain_core.tools import StructuredTool
```

Cette classe permet de créer un schéma structuré pour notre fonction, ce qui aide le modèle de langage à comprendre comment l'utiliser.

### Tool Node

La classe `ToolNode` de LangGraph est un composant qui simplifie considérablement l'intégration des outils :

```python
from langgraph.prebuilt import ToolNode
```

Cette classe joue un rôle essentiel car elle :
- Examine l'état du graphe pour trouver la clé "messages"
- Vérifie le dernier message pour identifier les appels d'outils
- Exécute automatiquement les outils appropriés, même en parallèle

Avant l'introduction de cette classe, il fallait implémenter manuellement toute cette logique, ce qui représentait un travail considérable.

## Stratégie d'implémentation

### Fonction d'exécution des requêtes

Nous définissons une fonction `run_queries` qui exécute une liste de requêtes de recherche :

```python
def run_queries(search_queries: list[str], **kwargs):
    """Run the generated queries."""
    return tavily_tool.batch([{"query": query} for query in search_queries])
```

Cette fonction utilise la méthode `batch` de l'outil Tavily pour exécuter plusieurs requêtes en parallèle.

### Création de deux outils distincts

La particularité de notre approche est de créer deux outils différents à partir de la même fonction de recherche :

```python
execute_tools = ToolNode(
    [
        StructuredTool.from_function(run_queries, name=AnswerQuestion.__name__),
        StructuredTool.from_function(run_queries, name=ReviseAnswer.__name__),
    ]
)
```

Ces deux outils ont exactement la même fonctionnalité (exécuter des recherches via Tavily) mais possèdent des noms différents :
- `AnswerQuestion` : utilisé pendant la phase initiale de recherche
- `ReviseAnswer` : utilisé pendant la phase de révision

Cette distinction permet de suivre clairement quelle étape du processus a déclenché la recherche, ce qui facilite le débogage et l'évaluation du système.

## Intégration avec le reste du système

Le fichier `chains.py` définit deux chaînes principales :
1. `first_responder` : génère une réponse initiale à la question de l'utilisateur
2. `revisor` : améliore la réponse en fonction des critiques et des nouvelles informations

L'exécuteur d'outils que nous avons créé (`execute_tools`) sera intégré dans un graphe LangGraph qui orchestrera le flux entre ces différentes étapes.

## Conclusion

L'exécuteur d'outils que nous avons implémenté constitue une partie essentielle de notre agent de réflexion. En utilisant les classes `StructuredTool` et `ToolNode`, nous avons pu simplifier considérablement le processus d'intégration des outils de recherche dans notre système.

La distinction entre les phases de recherche initiale et de révision, bien qu'utilisant la même fonctionnalité sous-jacente, permet d'améliorer la traçabilité et l'analyse du comportement de l'agent.


